{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.executeOperation = void 0;\nconst error_1 = require(\"../error\");\nconst read_preference_1 = require(\"../read_preference\");\nconst server_selection_1 = require(\"../sdam/server_selection\");\nconst utils_1 = require(\"../utils\");\nconst operation_1 = require(\"./operation\");\nconst MMAPv1_RETRY_WRITES_ERROR_CODE = error_1.MONGODB_ERROR_CODES.IllegalOperation;\nconst MMAPv1_RETRY_WRITES_ERROR_MESSAGE = 'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';\nfunction executeOperation(client, operation, callback) {\n  if (!(operation instanceof operation_1.AbstractOperation)) {\n    // TODO(NODE-3483): Extend MongoRuntimeError\n    throw new error_1.MongoRuntimeError('This method requires a valid operation instance');\n  }\n  return (0, utils_1.maybePromise)(callback, callback => {\n    const topology = client.topology;\n    if (topology == null) {\n      if (client.s.hasBeenClosed) {\n        return callback(new error_1.MongoNotConnectedError('Client must be connected before running operations'));\n      }\n      client.s.options[Symbol.for('@@mdb.skipPingOnConnect')] = true;\n      return client.connect(error => {\n        delete client.s.options[Symbol.for('@@mdb.skipPingOnConnect')];\n        if (error) {\n          return callback(error);\n        }\n        return executeOperation(client, operation, callback);\n      });\n    }\n    if (topology.shouldCheckForSessionSupport()) {\n      return topology.selectServer(read_preference_1.ReadPreference.primaryPreferred, {}, err => {\n        if (err) return callback(err);\n        executeOperation(client, operation, callback);\n      });\n    }\n    // The driver sessions spec mandates that we implicitly create sessions for operations\n    // that are not explicitly provided with a session.\n    let session = operation.session;\n    let owner;\n    if (topology.hasSessionSupport()) {\n      if (session == null) {\n        owner = Symbol();\n        session = client.startSession({\n          owner,\n          explicit: false\n        });\n      } else if (session.hasEnded) {\n        return callback(new error_1.MongoExpiredSessionError('Use of expired sessions is not permitted'));\n      } else if (session.snapshotEnabled && !topology.capabilities.supportsSnapshotReads) {\n        return callback(new error_1.MongoCompatibilityError('Snapshot reads require MongoDB 5.0 or later'));\n      }\n    } else {\n      // no session support\n      if (session && session.explicit) {\n        // If the user passed an explicit session and we are still, after server selection,\n        // trying to run against a topology that doesn't support sessions we error out.\n        return callback(new error_1.MongoCompatibilityError('Current topology does not support sessions'));\n      } else if (session && !session.explicit) {\n        // We do not have to worry about ending the session because the server session has not been acquired yet\n        delete operation.options.session;\n        operation.clearSession();\n        session = undefined;\n      }\n    }\n    try {\n      executeWithServerSelection(topology, session, operation, (error, result) => {\n        if ((session === null || session === void 0 ? void 0 : session.owner) != null && session.owner === owner) {\n          return session.endSession(endSessionError => callback(endSessionError !== null && endSessionError !== void 0 ? endSessionError : error, result));\n        }\n        callback(error, result);\n      });\n    } catch (error) {\n      if ((session === null || session === void 0 ? void 0 : session.owner) != null && session.owner === owner) {\n        session.endSession().catch(() => null);\n      }\n      throw error;\n    }\n  });\n}\nexports.executeOperation = executeOperation;\nfunction executeWithServerSelection(topology, session, operation, callback) {\n  var _a, _b;\n  const readPreference = (_a = operation.readPreference) !== null && _a !== void 0 ? _a : read_preference_1.ReadPreference.primary;\n  const inTransaction = !!(session === null || session === void 0 ? void 0 : session.inTransaction());\n  if (inTransaction && !readPreference.equals(read_preference_1.ReadPreference.primary)) {\n    return callback(new error_1.MongoTransactionError(`Read preference in a transaction must be primary, not: ${readPreference.mode}`));\n  }\n  if ((session === null || session === void 0 ? void 0 : session.isPinned) && session.transaction.isCommitted && !operation.bypassPinningCheck) {\n    session.unpin();\n  }\n  let selector;\n  if (operation.hasAspect(operation_1.Aspect.MUST_SELECT_SAME_SERVER)) {\n    // GetMore and KillCursor operations must always select the same server, but run through\n    // server selection to potentially force monitor checks if the server is\n    // in an unknown state.\n    selector = (0, server_selection_1.sameServerSelector)((_b = operation.server) === null || _b === void 0 ? void 0 : _b.description);\n  } else if (operation.trySecondaryWrite) {\n    // If operation should try to write to secondary use the custom server selector\n    // otherwise provide the read preference.\n    selector = (0, server_selection_1.secondaryWritableServerSelector)(topology.commonWireVersion, readPreference);\n  } else {\n    selector = readPreference;\n  }\n  const serverSelectionOptions = {\n    session\n  };\n  function retryOperation(originalError) {\n    const isWriteOperation = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);\n    const isReadOperation = operation.hasAspect(operation_1.Aspect.READ_OPERATION);\n    if (isWriteOperation && originalError.code === MMAPv1_RETRY_WRITES_ERROR_CODE) {\n      return callback(new error_1.MongoServerError({\n        message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n        errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n        originalError\n      }));\n    }\n    if (isWriteOperation && !(0, error_1.isRetryableWriteError)(originalError)) {\n      return callback(originalError);\n    }\n    if (isReadOperation && !(0, error_1.isRetryableReadError)(originalError)) {\n      return callback(originalError);\n    }\n    if (originalError instanceof error_1.MongoNetworkError && (session === null || session === void 0 ? void 0 : session.isPinned) && !session.inTransaction() && operation.hasAspect(operation_1.Aspect.CURSOR_CREATING)) {\n      // If we have a cursor and the initial command fails with a network error,\n      // we can retry it on another connection. So we need to check it back in, clear the\n      // pool for the service id, and retry again.\n      session.unpin({\n        force: true,\n        forceClear: true\n      });\n    }\n    // select a new server, and attempt to retry the operation\n    topology.selectServer(selector, serverSelectionOptions, (error, server) => {\n      if (!error && isWriteOperation && !(0, utils_1.supportsRetryableWrites)(server)) {\n        return callback(new error_1.MongoUnexpectedServerResponseError('Selected server does not support retryable writes'));\n      }\n      if (error || !server) {\n        return callback(error !== null && error !== void 0 ? error : new error_1.MongoUnexpectedServerResponseError('Server selection failed without error'));\n      }\n      operation.execute(server, session, callback);\n    });\n  }\n  if (readPreference && !readPreference.equals(read_preference_1.ReadPreference.primary) && (session === null || session === void 0 ? void 0 : session.inTransaction())) {\n    callback(new error_1.MongoTransactionError(`Read preference in a transaction must be primary, not: ${readPreference.mode}`));\n    return;\n  }\n  // select a server, and execute the operation against it\n  topology.selectServer(selector, serverSelectionOptions, (error, server) => {\n    if (error || !server) {\n      return callback(error);\n    }\n    if (session && operation.hasAspect(operation_1.Aspect.RETRYABLE)) {\n      const willRetryRead = topology.s.options.retryReads && !inTransaction && operation.canRetryRead;\n      const willRetryWrite = topology.s.options.retryWrites && !inTransaction && (0, utils_1.supportsRetryableWrites)(server) && operation.canRetryWrite;\n      const hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);\n      const hasWriteAspect = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);\n      if (hasReadAspect && willRetryRead || hasWriteAspect && willRetryWrite) {\n        if (hasWriteAspect && willRetryWrite) {\n          operation.options.willRetryWrite = true;\n          session.incrementTransactionNumber();\n        }\n        return operation.execute(server, session, (error, result) => {\n          if (error instanceof error_1.MongoError) {\n            return retryOperation(error);\n          } else if (error) {\n            return callback(error);\n          }\n          callback(undefined, result);\n        });\n      }\n    }\n    return operation.execute(server, session, callback);\n  });\n}","map":{"version":3,"names":["error_1","require","read_preference_1","server_selection_1","utils_1","operation_1","MMAPv1_RETRY_WRITES_ERROR_CODE","MONGODB_ERROR_CODES","IllegalOperation","MMAPv1_RETRY_WRITES_ERROR_MESSAGE","executeOperation","client","operation","callback","AbstractOperation","MongoRuntimeError","maybePromise","topology","s","hasBeenClosed","MongoNotConnectedError","options","Symbol","for","connect","error","shouldCheckForSessionSupport","selectServer","ReadPreference","primaryPreferred","err","session","owner","hasSessionSupport","startSession","explicit","hasEnded","MongoExpiredSessionError","snapshotEnabled","capabilities","supportsSnapshotReads","MongoCompatibilityError","clearSession","undefined","executeWithServerSelection","result","endSession","endSessionError","catch","exports","readPreference","_a","primary","inTransaction","equals","MongoTransactionError","mode","isPinned","transaction","isCommitted","bypassPinningCheck","unpin","selector","hasAspect","Aspect","MUST_SELECT_SAME_SERVER","sameServerSelector","_b","server","description","trySecondaryWrite","secondaryWritableServerSelector","commonWireVersion","serverSelectionOptions","retryOperation","originalError","isWriteOperation","WRITE_OPERATION","isReadOperation","READ_OPERATION","code","MongoServerError","message","errmsg","isRetryableWriteError","isRetryableReadError","MongoNetworkError","CURSOR_CREATING","force","forceClear","supportsRetryableWrites","MongoUnexpectedServerResponseError","execute","RETRYABLE","willRetryRead","retryReads","canRetryRead","willRetryWrite","retryWrites","canRetryWrite","hasReadAspect","hasWriteAspect","incrementTransactionNumber","MongoError"],"sources":["C:\\Users\\Jatin\\node_modules\\mongodb\\src\\operations\\execute_operation.ts"],"sourcesContent":["import type { Document } from '../bson';\nimport {\n  isRetryableReadError,\n  isRetryableWriteError,\n  MongoCompatibilityError,\n  MONGODB_ERROR_CODES,\n  MongoError,\n  MongoExpiredSessionError,\n  MongoNetworkError,\n  MongoNotConnectedError,\n  MongoRuntimeError,\n  MongoServerError,\n  MongoTransactionError,\n  MongoUnexpectedServerResponseError\n} from '../error';\nimport type { MongoClient } from '../mongo_client';\nimport { ReadPreference } from '../read_preference';\nimport type { Server } from '../sdam/server';\nimport {\n  sameServerSelector,\n  secondaryWritableServerSelector,\n  ServerSelector\n} from '../sdam/server_selection';\nimport type { Topology } from '../sdam/topology';\nimport type { ClientSession } from '../sessions';\nimport { Callback, maybePromise, supportsRetryableWrites } from '../utils';\nimport { AbstractOperation, Aspect } from './operation';\n\nconst MMAPv1_RETRY_WRITES_ERROR_CODE = MONGODB_ERROR_CODES.IllegalOperation;\nconst MMAPv1_RETRY_WRITES_ERROR_MESSAGE =\n  'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';\n\ntype ResultTypeFromOperation<TOperation> = TOperation extends AbstractOperation<infer K>\n  ? K\n  : never;\n\n/** @internal */\nexport interface ExecutionResult {\n  /** The server selected for the operation */\n  server: Server;\n  /** The session used for this operation, may be implicitly created */\n  session?: ClientSession;\n  /** The raw server response for the operation */\n  response: Document;\n}\n\n/**\n * Executes the given operation with provided arguments.\n * @internal\n *\n * @remarks\n * This method reduces large amounts of duplication in the entire codebase by providing\n * a single point for determining whether callbacks or promises should be used. Additionally\n * it allows for a single point of entry to provide features such as implicit sessions, which\n * are required by the Driver Sessions specification in the event that a ClientSession is\n * not provided\n *\n * @param topology - The topology to execute this operation on\n * @param operation - The operation to execute\n * @param callback - The command result callback\n */\nexport function executeOperation<\n  T extends AbstractOperation<TResult>,\n  TResult = ResultTypeFromOperation<T>\n>(client: MongoClient, operation: T): Promise<TResult>;\nexport function executeOperation<\n  T extends AbstractOperation<TResult>,\n  TResult = ResultTypeFromOperation<T>\n>(client: MongoClient, operation: T, callback: Callback<TResult>): void;\nexport function executeOperation<\n  T extends AbstractOperation<TResult>,\n  TResult = ResultTypeFromOperation<T>\n>(client: MongoClient, operation: T, callback?: Callback<TResult>): Promise<TResult> | void;\nexport function executeOperation<\n  T extends AbstractOperation<TResult>,\n  TResult = ResultTypeFromOperation<T>\n>(client: MongoClient, operation: T, callback?: Callback<TResult>): Promise<TResult> | void {\n  if (!(operation instanceof AbstractOperation)) {\n    // TODO(NODE-3483): Extend MongoRuntimeError\n    throw new MongoRuntimeError('This method requires a valid operation instance');\n  }\n\n  return maybePromise(callback, callback => {\n    const topology = client.topology;\n\n    if (topology == null) {\n      if (client.s.hasBeenClosed) {\n        return callback(\n          new MongoNotConnectedError('Client must be connected before running operations')\n        );\n      }\n      client.s.options[Symbol.for('@@mdb.skipPingOnConnect')] = true;\n      return client.connect(error => {\n        delete client.s.options[Symbol.for('@@mdb.skipPingOnConnect')];\n        if (error) {\n          return callback(error);\n        }\n        return executeOperation<T, TResult>(client, operation, callback);\n      });\n    }\n\n    if (topology.shouldCheckForSessionSupport()) {\n      return topology.selectServer(ReadPreference.primaryPreferred, {}, err => {\n        if (err) return callback(err);\n\n        executeOperation<T, TResult>(client, operation, callback);\n      });\n    }\n\n    // The driver sessions spec mandates that we implicitly create sessions for operations\n    // that are not explicitly provided with a session.\n    let session = operation.session;\n    let owner: symbol | undefined;\n    if (topology.hasSessionSupport()) {\n      if (session == null) {\n        owner = Symbol();\n        session = client.startSession({ owner, explicit: false });\n      } else if (session.hasEnded) {\n        return callback(new MongoExpiredSessionError('Use of expired sessions is not permitted'));\n      } else if (session.snapshotEnabled && !topology.capabilities.supportsSnapshotReads) {\n        return callback(new MongoCompatibilityError('Snapshot reads require MongoDB 5.0 or later'));\n      }\n    } else {\n      // no session support\n      if (session && session.explicit) {\n        // If the user passed an explicit session and we are still, after server selection,\n        // trying to run against a topology that doesn't support sessions we error out.\n        return callback(new MongoCompatibilityError('Current topology does not support sessions'));\n      } else if (session && !session.explicit) {\n        // We do not have to worry about ending the session because the server session has not been acquired yet\n        delete operation.options.session;\n        operation.clearSession();\n        session = undefined;\n      }\n    }\n\n    try {\n      executeWithServerSelection<TResult>(topology, session, operation, (error, result) => {\n        if (session?.owner != null && session.owner === owner) {\n          return session.endSession(endSessionError => callback(endSessionError ?? error, result));\n        }\n\n        callback(error, result);\n      });\n    } catch (error) {\n      if (session?.owner != null && session.owner === owner) {\n        session.endSession().catch(() => null);\n      }\n\n      throw error;\n    }\n  });\n}\n\nfunction executeWithServerSelection<TResult>(\n  topology: Topology,\n  session: ClientSession | undefined,\n  operation: AbstractOperation,\n  callback: Callback<TResult>\n) {\n  const readPreference = operation.readPreference ?? ReadPreference.primary;\n  const inTransaction = !!session?.inTransaction();\n\n  if (inTransaction && !readPreference.equals(ReadPreference.primary)) {\n    return callback(\n      new MongoTransactionError(\n        `Read preference in a transaction must be primary, not: ${readPreference.mode}`\n      )\n    );\n  }\n\n  if (session?.isPinned && session.transaction.isCommitted && !operation.bypassPinningCheck) {\n    session.unpin();\n  }\n\n  let selector: ReadPreference | ServerSelector;\n\n  if (operation.hasAspect(Aspect.MUST_SELECT_SAME_SERVER)) {\n    // GetMore and KillCursor operations must always select the same server, but run through\n    // server selection to potentially force monitor checks if the server is\n    // in an unknown state.\n    selector = sameServerSelector(operation.server?.description);\n  } else if (operation.trySecondaryWrite) {\n    // If operation should try to write to secondary use the custom server selector\n    // otherwise provide the read preference.\n    selector = secondaryWritableServerSelector(topology.commonWireVersion, readPreference);\n  } else {\n    selector = readPreference;\n  }\n\n  const serverSelectionOptions = { session };\n  function retryOperation(originalError: MongoError) {\n    const isWriteOperation = operation.hasAspect(Aspect.WRITE_OPERATION);\n    const isReadOperation = operation.hasAspect(Aspect.READ_OPERATION);\n\n    if (isWriteOperation && originalError.code === MMAPv1_RETRY_WRITES_ERROR_CODE) {\n      return callback(\n        new MongoServerError({\n          message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n          errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n          originalError\n        })\n      );\n    }\n\n    if (isWriteOperation && !isRetryableWriteError(originalError)) {\n      return callback(originalError);\n    }\n\n    if (isReadOperation && !isRetryableReadError(originalError)) {\n      return callback(originalError);\n    }\n\n    if (\n      originalError instanceof MongoNetworkError &&\n      session?.isPinned &&\n      !session.inTransaction() &&\n      operation.hasAspect(Aspect.CURSOR_CREATING)\n    ) {\n      // If we have a cursor and the initial command fails with a network error,\n      // we can retry it on another connection. So we need to check it back in, clear the\n      // pool for the service id, and retry again.\n      session.unpin({ force: true, forceClear: true });\n    }\n\n    // select a new server, and attempt to retry the operation\n    topology.selectServer(selector, serverSelectionOptions, (error?: Error, server?: Server) => {\n      if (!error && isWriteOperation && !supportsRetryableWrites(server)) {\n        return callback(\n          new MongoUnexpectedServerResponseError(\n            'Selected server does not support retryable writes'\n          )\n        );\n      }\n\n      if (error || !server) {\n        return callback(\n          error ?? new MongoUnexpectedServerResponseError('Server selection failed without error')\n        );\n      }\n\n      operation.execute(server, session, callback);\n    });\n  }\n\n  if (\n    readPreference &&\n    !readPreference.equals(ReadPreference.primary) &&\n    session?.inTransaction()\n  ) {\n    callback(\n      new MongoTransactionError(\n        `Read preference in a transaction must be primary, not: ${readPreference.mode}`\n      )\n    );\n\n    return;\n  }\n\n  // select a server, and execute the operation against it\n  topology.selectServer(selector, serverSelectionOptions, (error, server) => {\n    if (error || !server) {\n      return callback(error);\n    }\n\n    if (session && operation.hasAspect(Aspect.RETRYABLE)) {\n      const willRetryRead =\n        topology.s.options.retryReads && !inTransaction && operation.canRetryRead;\n\n      const willRetryWrite =\n        topology.s.options.retryWrites &&\n        !inTransaction &&\n        supportsRetryableWrites(server) &&\n        operation.canRetryWrite;\n\n      const hasReadAspect = operation.hasAspect(Aspect.READ_OPERATION);\n      const hasWriteAspect = operation.hasAspect(Aspect.WRITE_OPERATION);\n\n      if ((hasReadAspect && willRetryRead) || (hasWriteAspect && willRetryWrite)) {\n        if (hasWriteAspect && willRetryWrite) {\n          operation.options.willRetryWrite = true;\n          session.incrementTransactionNumber();\n        }\n\n        return operation.execute(server, session, (error, result) => {\n          if (error instanceof MongoError) {\n            return retryOperation(error);\n          } else if (error) {\n            return callback(error);\n          }\n          callback(undefined, result);\n        });\n      }\n    }\n\n    return operation.execute(server, session, callback);\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}