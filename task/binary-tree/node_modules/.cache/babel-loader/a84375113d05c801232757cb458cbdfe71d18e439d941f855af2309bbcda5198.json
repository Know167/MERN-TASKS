{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DropDatabaseOperation = exports.DropCollectionOperation = void 0;\nconst error_1 = require(\"../error\");\nconst command_1 = require(\"./command\");\nconst operation_1 = require(\"./operation\");\n/** @internal */\nclass DropCollectionOperation extends command_1.CommandOperation {\n  constructor(db, name) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super(db, options);\n    this.db = db;\n    this.options = options;\n    this.name = name;\n  }\n  execute(server, session, callback) {\n    (async () => {\n      var _a, _b, _c, _d;\n      const db = this.db;\n      const options = this.options;\n      const name = this.name;\n      const encryptedFieldsMap = (_a = db.s.client.options.autoEncryption) === null || _a === void 0 ? void 0 : _a.encryptedFieldsMap;\n      let encryptedFields = (_b = options.encryptedFields) !== null && _b !== void 0 ? _b : encryptedFieldsMap === null || encryptedFieldsMap === void 0 ? void 0 : encryptedFieldsMap[`${db.databaseName}.${name}`];\n      if (!encryptedFields && encryptedFieldsMap) {\n        // If the MongoClient was configued with an encryptedFieldsMap,\n        // and no encryptedFields config was available in it or explicitly\n        // passed as an argument, the spec tells us to look one up using\n        // listCollections().\n        const listCollectionsResult = await db.listCollections({\n          name\n        }, {\n          nameOnly: false\n        }).toArray();\n        encryptedFields = (_d = (_c = listCollectionsResult === null || listCollectionsResult === void 0 ? void 0 : listCollectionsResult[0]) === null || _c === void 0 ? void 0 : _c.options) === null || _d === void 0 ? void 0 : _d.encryptedFields;\n      }\n      if (encryptedFields) {\n        const escCollection = encryptedFields.escCollection || `enxcol_.${name}.esc`;\n        const eccCollection = encryptedFields.eccCollection || `enxcol_.${name}.ecc`;\n        const ecocCollection = encryptedFields.ecocCollection || `enxcol_.${name}.ecoc`;\n        for (const collectionName of [escCollection, eccCollection, ecocCollection]) {\n          // Drop auxilliary collections, ignoring potential NamespaceNotFound errors.\n          const dropOp = new DropCollectionOperation(db, collectionName);\n          try {\n            await dropOp.executeWithoutEncryptedFieldsCheck(server, session);\n          } catch (err) {\n            if (!(err instanceof error_1.MongoServerError) || err.code !== error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {\n              throw err;\n            }\n          }\n        }\n      }\n      return await this.executeWithoutEncryptedFieldsCheck(server, session);\n    })().then(result => callback(undefined, result), err => callback(err));\n  }\n  executeWithoutEncryptedFieldsCheck(server, session) {\n    return new Promise((resolve, reject) => {\n      super.executeCommand(server, session, {\n        drop: this.name\n      }, (err, result) => {\n        if (err) return reject(err);\n        resolve(!!result.ok);\n      });\n    });\n  }\n}\nexports.DropCollectionOperation = DropCollectionOperation;\n/** @internal */\nclass DropDatabaseOperation extends command_1.CommandOperation {\n  constructor(db, options) {\n    super(db, options);\n    this.options = options;\n  }\n  execute(server, session, callback) {\n    super.executeCommand(server, session, {\n      dropDatabase: 1\n    }, (err, result) => {\n      if (err) return callback(err);\n      if (result.ok) return callback(undefined, true);\n      callback(undefined, false);\n    });\n  }\n}\nexports.DropDatabaseOperation = DropDatabaseOperation;\n(0, operation_1.defineAspects)(DropCollectionOperation, [operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(DropDatabaseOperation, [operation_1.Aspect.WRITE_OPERATION]);","map":{"version":3,"names":["error_1","require","command_1","operation_1","DropCollectionOperation","CommandOperation","constructor","db","name","options","arguments","length","undefined","execute","server","session","callback","encryptedFieldsMap","_a","s","client","autoEncryption","encryptedFields","_b","databaseName","listCollectionsResult","listCollections","nameOnly","toArray","_d","_c","escCollection","eccCollection","ecocCollection","collectionName","dropOp","executeWithoutEncryptedFieldsCheck","err","MongoServerError","code","MONGODB_ERROR_CODES","NamespaceNotFound","then","result","Promise","resolve","reject","executeCommand","drop","ok","exports","DropDatabaseOperation","dropDatabase","defineAspects","Aspect","WRITE_OPERATION"],"sources":["C:\\Users\\Jatin\\node_modules\\mongodb\\src\\operations\\drop.ts"],"sourcesContent":["import type { Document } from '../bson';\nimport type { Db } from '../db';\nimport { MONGODB_ERROR_CODES, MongoServerError } from '../error';\nimport type { Server } from '../sdam/server';\nimport type { ClientSession } from '../sessions';\nimport type { Callback } from '../utils';\nimport { CommandOperation, CommandOperationOptions } from './command';\nimport { Aspect, defineAspects } from './operation';\n\n/** @public */\nexport interface DropCollectionOptions extends CommandOperationOptions {\n  /** @experimental */\n  encryptedFields?: Document;\n}\n\n/** @internal */\nexport class DropCollectionOperation extends CommandOperation<boolean> {\n  override options: DropCollectionOptions;\n  db: Db;\n  name: string;\n\n  constructor(db: Db, name: string, options: DropCollectionOptions = {}) {\n    super(db, options);\n    this.db = db;\n    this.options = options;\n    this.name = name;\n  }\n\n  override execute(\n    server: Server,\n    session: ClientSession | undefined,\n    callback: Callback<boolean>\n  ): void {\n    (async () => {\n      const db = this.db;\n      const options = this.options;\n      const name = this.name;\n\n      const encryptedFieldsMap = db.s.client.options.autoEncryption?.encryptedFieldsMap;\n      let encryptedFields: Document | undefined =\n        options.encryptedFields ?? encryptedFieldsMap?.[`${db.databaseName}.${name}`];\n\n      if (!encryptedFields && encryptedFieldsMap) {\n        // If the MongoClient was configued with an encryptedFieldsMap,\n        // and no encryptedFields config was available in it or explicitly\n        // passed as an argument, the spec tells us to look one up using\n        // listCollections().\n        const listCollectionsResult = await db\n          .listCollections({ name }, { nameOnly: false })\n          .toArray();\n        encryptedFields = listCollectionsResult?.[0]?.options?.encryptedFields;\n      }\n\n      if (encryptedFields) {\n        const escCollection = encryptedFields.escCollection || `enxcol_.${name}.esc`;\n        const eccCollection = encryptedFields.eccCollection || `enxcol_.${name}.ecc`;\n        const ecocCollection = encryptedFields.ecocCollection || `enxcol_.${name}.ecoc`;\n\n        for (const collectionName of [escCollection, eccCollection, ecocCollection]) {\n          // Drop auxilliary collections, ignoring potential NamespaceNotFound errors.\n          const dropOp = new DropCollectionOperation(db, collectionName);\n          try {\n            await dropOp.executeWithoutEncryptedFieldsCheck(server, session);\n          } catch (err) {\n            if (\n              !(err instanceof MongoServerError) ||\n              err.code !== MONGODB_ERROR_CODES.NamespaceNotFound\n            ) {\n              throw err;\n            }\n          }\n        }\n      }\n\n      return await this.executeWithoutEncryptedFieldsCheck(server, session);\n    })().then(\n      result => callback(undefined, result),\n      err => callback(err)\n    );\n  }\n\n  private executeWithoutEncryptedFieldsCheck(\n    server: Server,\n    session: ClientSession | undefined\n  ): Promise<boolean> {\n    return new Promise<boolean>((resolve, reject) => {\n      super.executeCommand(server, session, { drop: this.name }, (err, result) => {\n        if (err) return reject(err);\n        resolve(!!result.ok);\n      });\n    });\n  }\n}\n\n/** @public */\nexport type DropDatabaseOptions = CommandOperationOptions;\n\n/** @internal */\nexport class DropDatabaseOperation extends CommandOperation<boolean> {\n  override options: DropDatabaseOptions;\n\n  constructor(db: Db, options: DropDatabaseOptions) {\n    super(db, options);\n    this.options = options;\n  }\n  override execute(\n    server: Server,\n    session: ClientSession | undefined,\n    callback: Callback<boolean>\n  ): void {\n    super.executeCommand(server, session, { dropDatabase: 1 }, (err, result) => {\n      if (err) return callback(err);\n      if (result.ok) return callback(undefined, true);\n      callback(undefined, false);\n    });\n  }\n}\n\ndefineAspects(DropCollectionOperation, [Aspect.WRITE_OPERATION]);\ndefineAspects(DropDatabaseOperation, [Aspect.WRITE_OPERATION]);\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}