{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assertUninitialized = exports.next = exports.AbstractCursor = exports.CURSOR_FLAGS = void 0;\nconst stream_1 = require(\"stream\");\nconst bson_1 = require(\"../bson\");\nconst error_1 = require(\"../error\");\nconst mongo_types_1 = require(\"../mongo_types\");\nconst execute_operation_1 = require(\"../operations/execute_operation\");\nconst get_more_1 = require(\"../operations/get_more\");\nconst kill_cursors_1 = require(\"../operations/kill_cursors\");\nconst read_concern_1 = require(\"../read_concern\");\nconst read_preference_1 = require(\"../read_preference\");\nconst sessions_1 = require(\"../sessions\");\nconst utils_1 = require(\"../utils\");\n/** @internal */\nconst kId = Symbol('id');\n/** @internal */\nconst kDocuments = Symbol('documents');\n/** @internal */\nconst kServer = Symbol('server');\n/** @internal */\nconst kNamespace = Symbol('namespace');\n/** @internal */\nconst kClient = Symbol('client');\n/** @internal */\nconst kSession = Symbol('session');\n/** @internal */\nconst kOptions = Symbol('options');\n/** @internal */\nconst kTransform = Symbol('transform');\n/** @internal */\nconst kInitialized = Symbol('initialized');\n/** @internal */\nconst kClosed = Symbol('closed');\n/** @internal */\nconst kKilled = Symbol('killed');\n/** @internal */\nconst kInit = Symbol('kInit');\n/** @public */\nexports.CURSOR_FLAGS = ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'exhaust', 'partial'];\n/** @public */\nclass AbstractCursor extends mongo_types_1.TypedEventEmitter {\n  /** @internal */\n  constructor(client, namespace) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super();\n    if (!client.s.isMongoClient) {\n      throw new error_1.MongoRuntimeError('Cursor must be constructed with MongoClient');\n    }\n    this[kClient] = client;\n    this[kNamespace] = namespace;\n    this[kDocuments] = []; // TODO: https://github.com/microsoft/TypeScript/issues/36230\n    this[kInitialized] = false;\n    this[kClosed] = false;\n    this[kKilled] = false;\n    this[kOptions] = {\n      readPreference: options.readPreference && options.readPreference instanceof read_preference_1.ReadPreference ? options.readPreference : read_preference_1.ReadPreference.primary,\n      ...(0, bson_1.pluckBSONSerializeOptions)(options)\n    };\n    const readConcern = read_concern_1.ReadConcern.fromOptions(options);\n    if (readConcern) {\n      this[kOptions].readConcern = readConcern;\n    }\n    if (typeof options.batchSize === 'number') {\n      this[kOptions].batchSize = options.batchSize;\n    }\n    // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n    if (options.comment !== undefined) {\n      this[kOptions].comment = options.comment;\n    }\n    if (typeof options.maxTimeMS === 'number') {\n      this[kOptions].maxTimeMS = options.maxTimeMS;\n    }\n    if (options.session instanceof sessions_1.ClientSession) {\n      this[kSession] = options.session;\n    } else {\n      this[kSession] = this[kClient].startSession({\n        owner: this,\n        explicit: false\n      });\n    }\n  }\n  get id() {\n    return this[kId];\n  }\n  /** @internal */\n  get client() {\n    return this[kClient];\n  }\n  /** @internal */\n  get server() {\n    return this[kServer];\n  }\n  get namespace() {\n    return this[kNamespace];\n  }\n  get readPreference() {\n    return this[kOptions].readPreference;\n  }\n  get readConcern() {\n    return this[kOptions].readConcern;\n  }\n  /** @internal */\n  get session() {\n    return this[kSession];\n  }\n  set session(clientSession) {\n    this[kSession] = clientSession;\n  }\n  /** @internal */\n  get cursorOptions() {\n    return this[kOptions];\n  }\n  get closed() {\n    return this[kClosed];\n  }\n  get killed() {\n    return this[kKilled];\n  }\n  get loadBalanced() {\n    var _a;\n    return !!((_a = this[kClient].topology) === null || _a === void 0 ? void 0 : _a.loadBalanced);\n  }\n  /** Returns current buffered documents length */\n  bufferedCount() {\n    return this[kDocuments].length;\n  }\n  /** Returns current buffered documents */\n  readBufferedDocuments(number) {\n    return this[kDocuments].splice(0, number !== null && number !== void 0 ? number : this[kDocuments].length);\n  }\n  [Symbol.asyncIterator]() {\n    return {\n      next: () => this.next().then(value => value != null ? {\n        value,\n        done: false\n      } : {\n        value: undefined,\n        done: true\n      })\n    };\n  }\n  stream(options) {\n    if (options === null || options === void 0 ? void 0 : options.transform) {\n      const transform = options.transform;\n      const readable = new ReadableCursorStream(this);\n      return readable.pipe(new stream_1.Transform({\n        objectMode: true,\n        highWaterMark: 1,\n        transform(chunk, _, callback) {\n          try {\n            const transformed = transform(chunk);\n            callback(undefined, transformed);\n          } catch (err) {\n            callback(err);\n          }\n        }\n      }));\n    }\n    return new ReadableCursorStream(this);\n  }\n  hasNext(callback) {\n    return (0, utils_1.maybePromise)(callback, done => {\n      if (this[kId] === bson_1.Long.ZERO) {\n        return done(undefined, false);\n      }\n      if (this[kDocuments].length) {\n        return done(undefined, true);\n      }\n      next(this, true, (err, doc) => {\n        if (err) return done(err);\n        if (doc) {\n          this[kDocuments].unshift(doc);\n          done(undefined, true);\n          return;\n        }\n        done(undefined, false);\n      });\n    });\n  }\n  next(callback) {\n    return (0, utils_1.maybePromise)(callback, done => {\n      if (this[kId] === bson_1.Long.ZERO) {\n        return done(new error_1.MongoCursorExhaustedError());\n      }\n      next(this, true, done);\n    });\n  }\n  tryNext(callback) {\n    return (0, utils_1.maybePromise)(callback, done => {\n      if (this[kId] === bson_1.Long.ZERO) {\n        return done(new error_1.MongoCursorExhaustedError());\n      }\n      next(this, false, done);\n    });\n  }\n  forEach(iterator, callback) {\n    if (typeof iterator !== 'function') {\n      throw new error_1.MongoInvalidArgumentError('Argument \"iterator\" must be a function');\n    }\n    return (0, utils_1.maybePromise)(callback, done => {\n      const transform = this[kTransform];\n      const fetchDocs = () => {\n        next(this, true, (err, doc) => {\n          if (err || doc == null) return done(err);\n          let result;\n          // NOTE: no need to transform because `next` will do this automatically\n          try {\n            result = iterator(doc); // TODO(NODE-3283): Improve transform typing\n          } catch (error) {\n            return done(error);\n          }\n          if (result === false) return done();\n          // these do need to be transformed since they are copying the rest of the batch\n          const internalDocs = this[kDocuments].splice(0, this[kDocuments].length);\n          for (let i = 0; i < internalDocs.length; ++i) {\n            try {\n              result = iterator(transform ? transform(internalDocs[i]) : internalDocs[i] // TODO(NODE-3283): Improve transform typing\n              );\n            } catch (error) {\n              return done(error);\n            }\n            if (result === false) return done();\n          }\n          fetchDocs();\n        });\n      };\n      fetchDocs();\n    });\n  }\n  close(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = options !== null && options !== void 0 ? options : {};\n    const needsToEmitClosed = !this[kClosed];\n    this[kClosed] = true;\n    return (0, utils_1.maybePromise)(callback, done => cleanupCursor(this, {\n      needsToEmitClosed\n    }, done));\n  }\n  toArray(callback) {\n    return (0, utils_1.maybePromise)(callback, done => {\n      const docs = [];\n      const transform = this[kTransform];\n      const fetchDocs = () => {\n        // NOTE: if we add a `nextBatch` then we should use it here\n        next(this, true, (err, doc) => {\n          if (err) return done(err);\n          if (doc == null) return done(undefined, docs);\n          // NOTE: no need to transform because `next` will do this automatically\n          docs.push(doc);\n          // these do need to be transformed since they are copying the rest of the batch\n          const internalDocs = transform ? this[kDocuments].splice(0, this[kDocuments].length).map(transform) : this[kDocuments].splice(0, this[kDocuments].length); // TODO(NODE-3283): Improve transform typing\n          if (internalDocs) {\n            docs.push(...internalDocs);\n          }\n          fetchDocs();\n        });\n      };\n      fetchDocs();\n    });\n  }\n  /**\n   * Add a cursor flag to the cursor\n   *\n   * @param flag - The flag to set, must be one of following ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial' -.\n   * @param value - The flag boolean value.\n   */\n  addCursorFlag(flag, value) {\n    assertUninitialized(this);\n    if (!exports.CURSOR_FLAGS.includes(flag)) {\n      throw new error_1.MongoInvalidArgumentError(`Flag ${flag} is not one of ${exports.CURSOR_FLAGS}`);\n    }\n    if (typeof value !== 'boolean') {\n      throw new error_1.MongoInvalidArgumentError(`Flag ${flag} must be a boolean value`);\n    }\n    this[kOptions][flag] = value;\n    return this;\n  }\n  /**\n   * Map all documents using the provided function\n   * If there is a transform set on the cursor, that will be called first and the result passed to\n   * this function's transform.\n   *\n   * @remarks\n   * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,\n   * it **does not** return a new instance of a cursor. This means when calling map,\n   * you should always assign the result to a new variable in order to get a correctly typed cursor variable.\n   * Take note of the following example:\n   *\n   * @example\n   * ```typescript\n   * const cursor: FindCursor<Document> = coll.find();\n   * const mappedCursor: FindCursor<number> = cursor.map(doc => Object.keys(doc).length);\n   * const keyCounts: number[] = await mappedCursor.toArray(); // cursor.toArray() still returns Document[]\n   * ```\n   * @param transform - The mapping transformation method.\n   */\n  map(transform) {\n    assertUninitialized(this);\n    const oldTransform = this[kTransform]; // TODO(NODE-3283): Improve transform typing\n    if (oldTransform) {\n      this[kTransform] = doc => {\n        return transform(oldTransform(doc));\n      };\n    } else {\n      this[kTransform] = transform;\n    }\n    return this;\n  }\n  /**\n   * Set the ReadPreference for the cursor.\n   *\n   * @param readPreference - The new read preference for the cursor.\n   */\n  withReadPreference(readPreference) {\n    assertUninitialized(this);\n    if (readPreference instanceof read_preference_1.ReadPreference) {\n      this[kOptions].readPreference = readPreference;\n    } else if (typeof readPreference === 'string') {\n      this[kOptions].readPreference = read_preference_1.ReadPreference.fromString(readPreference);\n    } else {\n      throw new error_1.MongoInvalidArgumentError(`Invalid read preference: ${readPreference}`);\n    }\n    return this;\n  }\n  /**\n   * Set the ReadPreference for the cursor.\n   *\n   * @param readPreference - The new read preference for the cursor.\n   */\n  withReadConcern(readConcern) {\n    assertUninitialized(this);\n    const resolvedReadConcern = read_concern_1.ReadConcern.fromOptions({\n      readConcern\n    });\n    if (resolvedReadConcern) {\n      this[kOptions].readConcern = resolvedReadConcern;\n    }\n    return this;\n  }\n  /**\n   * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)\n   *\n   * @param value - Number of milliseconds to wait before aborting the query.\n   */\n  maxTimeMS(value) {\n    assertUninitialized(this);\n    if (typeof value !== 'number') {\n      throw new error_1.MongoInvalidArgumentError('Argument for maxTimeMS must be a number');\n    }\n    this[kOptions].maxTimeMS = value;\n    return this;\n  }\n  /**\n   * Set the batch size for the cursor.\n   *\n   * @param value - The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/find/|find command documentation}.\n   */\n  batchSize(value) {\n    assertUninitialized(this);\n    if (this[kOptions].tailable) {\n      throw new error_1.MongoTailableCursorError('Tailable cursor does not support batchSize');\n    }\n    if (typeof value !== 'number') {\n      throw new error_1.MongoInvalidArgumentError('Operation \"batchSize\" requires an integer');\n    }\n    this[kOptions].batchSize = value;\n    return this;\n  }\n  /**\n   * Rewind this cursor to its uninitialized state. Any options that are present on the cursor will\n   * remain in effect. Iterating this cursor will cause new queries to be sent to the server, even\n   * if the resultant data has already been retrieved by this cursor.\n   */\n  rewind() {\n    if (!this[kInitialized]) {\n      return;\n    }\n    this[kId] = undefined;\n    this[kDocuments] = [];\n    this[kClosed] = false;\n    this[kKilled] = false;\n    this[kInitialized] = false;\n    const session = this[kSession];\n    if (session) {\n      // We only want to end this session if we created it, and it hasn't ended yet\n      if (session.explicit === false) {\n        if (!session.hasEnded) {\n          session.endSession().catch(() => null);\n        }\n        this[kSession] = this.client.startSession({\n          owner: this,\n          explicit: false\n        });\n      }\n    }\n  }\n  /** @internal */\n  _getMore(batchSize, callback) {\n    const cursorId = this[kId];\n    const cursorNs = this[kNamespace];\n    const server = this[kServer];\n    if (cursorId == null) {\n      callback(new error_1.MongoRuntimeError('Unable to iterate cursor with no id'));\n      return;\n    }\n    if (server == null) {\n      callback(new error_1.MongoRuntimeError('Unable to iterate cursor without selected server'));\n      return;\n    }\n    const getMoreOperation = new get_more_1.GetMoreOperation(cursorNs, cursorId, server, {\n      ...this[kOptions],\n      session: this[kSession],\n      batchSize\n    });\n    (0, execute_operation_1.executeOperation)(this[kClient], getMoreOperation, callback);\n  }\n  /**\n   * @internal\n   *\n   * This function is exposed for the unified test runner's createChangeStream\n   * operation.  We cannot refactor to use the abstract _initialize method without\n   * a significant refactor.\n   */\n  [kInit](callback) {\n    this._initialize(this[kSession], (err, state) => {\n      if (state) {\n        const response = state.response;\n        this[kServer] = state.server;\n        if (response.cursor) {\n          this[kId] = typeof response.cursor.id === 'number' ? bson_1.Long.fromNumber(response.cursor.id) : response.cursor.id;\n          if (response.cursor.ns) {\n            this[kNamespace] = (0, utils_1.ns)(response.cursor.ns);\n          }\n          this[kDocuments] = response.cursor.firstBatch;\n        }\n        // When server responses return without a cursor document, we close this cursor\n        // and return the raw server response. This is often the case for explain commands\n        // for example\n        if (this[kId] == null) {\n          this[kId] = bson_1.Long.ZERO;\n          // TODO(NODE-3286): ExecutionResult needs to accept a generic parameter\n          this[kDocuments] = [state.response];\n        }\n      }\n      // the cursor is now initialized, even if an error occurred or it is dead\n      this[kInitialized] = true;\n      if (err || cursorIsDead(this)) {\n        return cleanupCursor(this, {\n          error: err\n        }, () => callback(err, nextDocument(this)));\n      }\n      callback();\n    });\n  }\n}\nexports.AbstractCursor = AbstractCursor;\n/** @event */\nAbstractCursor.CLOSE = 'close';\nfunction nextDocument(cursor) {\n  if (cursor[kDocuments] == null || !cursor[kDocuments].length) {\n    return null;\n  }\n  const doc = cursor[kDocuments].shift();\n  if (doc) {\n    const transform = cursor[kTransform];\n    if (transform) {\n      return transform(doc);\n    }\n    return doc;\n  }\n  return null;\n}\n/**\n * @param cursor - the cursor on which to call `next`\n * @param blocking - a boolean indicating whether or not the cursor should `block` until data\n *     is available.  Generally, this flag is set to `false` because if the getMore returns no documents,\n *     the cursor has been exhausted.  In certain scenarios (ChangeStreams, tailable await cursors and\n *     `tryNext`, for example) blocking is necessary because a getMore returning no documents does\n *     not indicate the end of the cursor.\n * @param callback - callback to return the result to the caller\n * @returns\n */\nfunction next(cursor, blocking, callback) {\n  const cursorId = cursor[kId];\n  if (cursor.closed) {\n    return callback(undefined, null);\n  }\n  if (cursor[kDocuments] && cursor[kDocuments].length) {\n    callback(undefined, nextDocument(cursor));\n    return;\n  }\n  if (cursorId == null) {\n    // All cursors must operate within a session, one must be made implicitly if not explicitly provided\n    cursor[kInit]((err, value) => {\n      if (err) return callback(err);\n      if (value) {\n        return callback(undefined, value);\n      }\n      return next(cursor, blocking, callback);\n    });\n    return;\n  }\n  if (cursorIsDead(cursor)) {\n    return cleanupCursor(cursor, undefined, () => callback(undefined, null));\n  }\n  // otherwise need to call getMore\n  const batchSize = cursor[kOptions].batchSize || 1000;\n  cursor._getMore(batchSize, (err, response) => {\n    if (response) {\n      const cursorId = typeof response.cursor.id === 'number' ? bson_1.Long.fromNumber(response.cursor.id) : response.cursor.id;\n      cursor[kDocuments] = response.cursor.nextBatch;\n      cursor[kId] = cursorId;\n    }\n    if (err || cursorIsDead(cursor)) {\n      return cleanupCursor(cursor, {\n        error: err\n      }, () => callback(err, nextDocument(cursor)));\n    }\n    if (cursor[kDocuments].length === 0 && blocking === false) {\n      return callback(undefined, null);\n    }\n    next(cursor, blocking, callback);\n  });\n}\nexports.next = next;\nfunction cursorIsDead(cursor) {\n  const cursorId = cursor[kId];\n  return !!cursorId && cursorId.isZero();\n}\nfunction cleanupCursor(cursor, options, callback) {\n  var _a;\n  const cursorId = cursor[kId];\n  const cursorNs = cursor[kNamespace];\n  const server = cursor[kServer];\n  const session = cursor[kSession];\n  const error = options === null || options === void 0 ? void 0 : options.error;\n  const needsToEmitClosed = (_a = options === null || options === void 0 ? void 0 : options.needsToEmitClosed) !== null && _a !== void 0 ? _a : cursor[kDocuments].length === 0;\n  if (error) {\n    if (cursor.loadBalanced && error instanceof error_1.MongoNetworkError) {\n      return completeCleanup();\n    }\n  }\n  if (cursorId == null || server == null || cursorId.isZero() || cursorNs == null) {\n    if (needsToEmitClosed) {\n      cursor[kClosed] = true;\n      cursor[kId] = bson_1.Long.ZERO;\n      cursor.emit(AbstractCursor.CLOSE);\n    }\n    if (session) {\n      if (session.owner === cursor) {\n        return session.endSession({\n          error\n        }, callback);\n      }\n      if (!session.inTransaction()) {\n        (0, sessions_1.maybeClearPinnedConnection)(session, {\n          error\n        });\n      }\n    }\n    return callback();\n  }\n  function completeCleanup() {\n    if (session) {\n      if (session.owner === cursor) {\n        return session.endSession({\n          error\n        }, () => {\n          cursor.emit(AbstractCursor.CLOSE);\n          callback();\n        });\n      }\n      if (!session.inTransaction()) {\n        (0, sessions_1.maybeClearPinnedConnection)(session, {\n          error\n        });\n      }\n    }\n    cursor.emit(AbstractCursor.CLOSE);\n    return callback();\n  }\n  cursor[kKilled] = true;\n  return (0, execute_operation_1.executeOperation)(cursor[kClient], new kill_cursors_1.KillCursorsOperation(cursorId, cursorNs, server, {\n    session\n  }), completeCleanup);\n}\n/** @internal */\nfunction assertUninitialized(cursor) {\n  if (cursor[kInitialized]) {\n    throw new error_1.MongoCursorInUseError();\n  }\n}\nexports.assertUninitialized = assertUninitialized;\nclass ReadableCursorStream extends stream_1.Readable {\n  constructor(cursor) {\n    super({\n      objectMode: true,\n      autoDestroy: false,\n      highWaterMark: 1\n    });\n    this._readInProgress = false;\n    this._cursor = cursor;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _read(size) {\n    if (!this._readInProgress) {\n      this._readInProgress = true;\n      this._readNext();\n    }\n  }\n  _destroy(error, callback) {\n    this._cursor.close(err => process.nextTick(callback, err || error));\n  }\n  _readNext() {\n    next(this._cursor, true, (err, result) => {\n      if (err) {\n        // NOTE: This is questionable, but we have a test backing the behavior. It seems the\n        //       desired behavior is that a stream ends cleanly when a user explicitly closes\n        //       a client during iteration. Alternatively, we could do the \"right\" thing and\n        //       propagate the error message by removing this special case.\n        if (err.message.match(/server is closed/)) {\n          this._cursor.close().catch(() => null);\n          return this.push(null);\n        }\n        // NOTE: This is also perhaps questionable. The rationale here is that these errors tend\n        //       to be \"operation interrupted\", where a cursor has been closed but there is an\n        //       active getMore in-flight. This used to check if the cursor was killed but once\n        //       that changed to happen in cleanup legitimate errors would not destroy the\n        //       stream. There are change streams test specifically test these cases.\n        if (err.message.match(/interrupted/)) {\n          return this.push(null);\n        }\n        return this.destroy(err);\n      }\n      if (result == null) {\n        this.push(null);\n      } else if (this.destroyed) {\n        this._cursor.close().catch(() => null);\n      } else {\n        if (this.push(result)) {\n          return this._readNext();\n        }\n        this._readInProgress = false;\n      }\n    });\n  }\n}","map":{"version":3,"names":["stream_1","require","bson_1","error_1","mongo_types_1","execute_operation_1","get_more_1","kill_cursors_1","read_concern_1","read_preference_1","sessions_1","utils_1","kId","Symbol","kDocuments","kServer","kNamespace","kClient","kSession","kOptions","kTransform","kInitialized","kClosed","kKilled","kInit","exports","CURSOR_FLAGS","AbstractCursor","TypedEventEmitter","constructor","client","namespace","options","arguments","length","undefined","s","isMongoClient","MongoRuntimeError","readPreference","ReadPreference","primary","pluckBSONSerializeOptions","readConcern","ReadConcern","fromOptions","batchSize","comment","maxTimeMS","session","ClientSession","startSession","owner","explicit","id","server","clientSession","cursorOptions","closed","killed","loadBalanced","_a","topology","bufferedCount","readBufferedDocuments","number","splice","asyncIterator","next","then","value","done","stream","transform","readable","ReadableCursorStream","pipe","Transform","objectMode","highWaterMark","chunk","_","callback","transformed","err","hasNext","maybePromise","Long","ZERO","doc","unshift","MongoCursorExhaustedError","tryNext","forEach","iterator","MongoInvalidArgumentError","fetchDocs","result","error","internalDocs","i","close","needsToEmitClosed","cleanupCursor","toArray","docs","push","map","addCursorFlag","flag","assertUninitialized","includes","oldTransform","withReadPreference","fromString","withReadConcern","resolvedReadConcern","tailable","MongoTailableCursorError","rewind","hasEnded","endSession","catch","_getMore","cursorId","cursorNs","getMoreOperation","GetMoreOperation","executeOperation","_initialize","state","response","cursor","fromNumber","ns","firstBatch","cursorIsDead","nextDocument","CLOSE","shift","blocking","nextBatch","isZero","MongoNetworkError","completeCleanup","emit","inTransaction","maybeClearPinnedConnection","KillCursorsOperation","MongoCursorInUseError","Readable","autoDestroy","_readInProgress","_cursor","_read","size","_readNext","_destroy","process","nextTick","message","match","destroy","destroyed"],"sources":["C:\\Users\\Jatin\\node_modules\\mongodb\\src\\cursor\\abstract_cursor.ts"],"sourcesContent":["import { Readable, Transform } from 'stream';\n\nimport { BSONSerializeOptions, Document, Long, pluckBSONSerializeOptions } from '../bson';\nimport {\n  AnyError,\n  MongoCursorExhaustedError,\n  MongoCursorInUseError,\n  MongoInvalidArgumentError,\n  MongoNetworkError,\n  MongoRuntimeError,\n  MongoTailableCursorError\n} from '../error';\nimport type { MongoClient } from '../mongo_client';\nimport { TODO_NODE_3286, TypedEventEmitter } from '../mongo_types';\nimport { executeOperation, ExecutionResult } from '../operations/execute_operation';\nimport { GetMoreOperation } from '../operations/get_more';\nimport { KillCursorsOperation } from '../operations/kill_cursors';\nimport { ReadConcern, ReadConcernLike } from '../read_concern';\nimport { ReadPreference, ReadPreferenceLike } from '../read_preference';\nimport type { Server } from '../sdam/server';\nimport { ClientSession, maybeClearPinnedConnection } from '../sessions';\nimport { Callback, maybePromise, MongoDBNamespace, ns } from '../utils';\n\n/** @internal */\nconst kId = Symbol('id');\n/** @internal */\nconst kDocuments = Symbol('documents');\n/** @internal */\nconst kServer = Symbol('server');\n/** @internal */\nconst kNamespace = Symbol('namespace');\n/** @internal */\nconst kClient = Symbol('client');\n/** @internal */\nconst kSession = Symbol('session');\n/** @internal */\nconst kOptions = Symbol('options');\n/** @internal */\nconst kTransform = Symbol('transform');\n/** @internal */\nconst kInitialized = Symbol('initialized');\n/** @internal */\nconst kClosed = Symbol('closed');\n/** @internal */\nconst kKilled = Symbol('killed');\n/** @internal */\nconst kInit = Symbol('kInit');\n\n/** @public */\nexport const CURSOR_FLAGS = [\n  'tailable',\n  'oplogReplay',\n  'noCursorTimeout',\n  'awaitData',\n  'exhaust',\n  'partial'\n] as const;\n\n/** @public\n * @deprecated This interface is deprecated */\nexport interface CursorCloseOptions {\n  /** Bypass calling killCursors when closing the cursor. */\n  /** @deprecated  the skipKillCursors option is deprecated */\n  skipKillCursors?: boolean;\n}\n\n/** @public */\nexport interface CursorStreamOptions {\n  /** A transformation method applied to each document emitted by the stream */\n  transform?(this: void, doc: Document): Document;\n}\n\n/** @public */\nexport type CursorFlag = typeof CURSOR_FLAGS[number];\n\n/** @public */\nexport interface AbstractCursorOptions extends BSONSerializeOptions {\n  session?: ClientSession;\n  readPreference?: ReadPreferenceLike;\n  readConcern?: ReadConcernLike;\n  batchSize?: number;\n  maxTimeMS?: number;\n  /**\n   * Comment to apply to the operation.\n   *\n   * In server versions pre-4.4, 'comment' must be string.  A server\n   * error will be thrown if any other type is provided.\n   *\n   * In server versions 4.4 and above, 'comment' can be any valid BSON type.\n   */\n  comment?: unknown;\n  tailable?: boolean;\n  awaitData?: boolean;\n  noCursorTimeout?: boolean;\n}\n\n/** @internal */\nexport type InternalAbstractCursorOptions = Omit<AbstractCursorOptions, 'readPreference'> & {\n  // resolved\n  readPreference: ReadPreference;\n  readConcern?: ReadConcern;\n\n  // cursor flags, some are deprecated\n  oplogReplay?: boolean;\n  exhaust?: boolean;\n  partial?: boolean;\n};\n\n/** @public */\nexport type AbstractCursorEvents = {\n  [AbstractCursor.CLOSE](): void;\n};\n\n/** @public */\nexport abstract class AbstractCursor<\n  TSchema = any,\n  CursorEvents extends AbstractCursorEvents = AbstractCursorEvents\n> extends TypedEventEmitter<CursorEvents> {\n  /** @internal */\n  [kId]?: Long;\n  /** @internal */\n  [kSession]: ClientSession;\n  /** @internal */\n  [kServer]?: Server;\n  /** @internal */\n  [kNamespace]: MongoDBNamespace;\n  /** @internal */\n  [kDocuments]: TSchema[];\n  /** @internal */\n  [kClient]: MongoClient;\n  /** @internal */\n  [kTransform]?: (doc: TSchema) => any;\n  /** @internal */\n  [kInitialized]: boolean;\n  /** @internal */\n  [kClosed]: boolean;\n  /** @internal */\n  [kKilled]: boolean;\n  /** @internal */\n  [kOptions]: InternalAbstractCursorOptions;\n\n  /** @event */\n  static readonly CLOSE = 'close' as const;\n\n  /** @internal */\n  constructor(\n    client: MongoClient,\n    namespace: MongoDBNamespace,\n    options: AbstractCursorOptions = {}\n  ) {\n    super();\n\n    if (!client.s.isMongoClient) {\n      throw new MongoRuntimeError('Cursor must be constructed with MongoClient');\n    }\n    this[kClient] = client;\n    this[kNamespace] = namespace;\n    this[kDocuments] = []; // TODO: https://github.com/microsoft/TypeScript/issues/36230\n    this[kInitialized] = false;\n    this[kClosed] = false;\n    this[kKilled] = false;\n    this[kOptions] = {\n      readPreference:\n        options.readPreference && options.readPreference instanceof ReadPreference\n          ? options.readPreference\n          : ReadPreference.primary,\n      ...pluckBSONSerializeOptions(options)\n    };\n\n    const readConcern = ReadConcern.fromOptions(options);\n    if (readConcern) {\n      this[kOptions].readConcern = readConcern;\n    }\n\n    if (typeof options.batchSize === 'number') {\n      this[kOptions].batchSize = options.batchSize;\n    }\n\n    // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n    if (options.comment !== undefined) {\n      this[kOptions].comment = options.comment;\n    }\n\n    if (typeof options.maxTimeMS === 'number') {\n      this[kOptions].maxTimeMS = options.maxTimeMS;\n    }\n\n    if (options.session instanceof ClientSession) {\n      this[kSession] = options.session;\n    } else {\n      this[kSession] = this[kClient].startSession({ owner: this, explicit: false });\n    }\n  }\n\n  get id(): Long | undefined {\n    return this[kId];\n  }\n\n  /** @internal */\n  get client(): MongoClient {\n    return this[kClient];\n  }\n\n  /** @internal */\n  get server(): Server | undefined {\n    return this[kServer];\n  }\n\n  get namespace(): MongoDBNamespace {\n    return this[kNamespace];\n  }\n\n  get readPreference(): ReadPreference {\n    return this[kOptions].readPreference;\n  }\n\n  get readConcern(): ReadConcern | undefined {\n    return this[kOptions].readConcern;\n  }\n\n  /** @internal */\n  get session(): ClientSession {\n    return this[kSession];\n  }\n\n  set session(clientSession: ClientSession) {\n    this[kSession] = clientSession;\n  }\n\n  /** @internal */\n  get cursorOptions(): InternalAbstractCursorOptions {\n    return this[kOptions];\n  }\n\n  get closed(): boolean {\n    return this[kClosed];\n  }\n\n  get killed(): boolean {\n    return this[kKilled];\n  }\n\n  get loadBalanced(): boolean {\n    return !!this[kClient].topology?.loadBalanced;\n  }\n\n  /** Returns current buffered documents length */\n  bufferedCount(): number {\n    return this[kDocuments].length;\n  }\n\n  /** Returns current buffered documents */\n  readBufferedDocuments(number?: number): TSchema[] {\n    return this[kDocuments].splice(0, number ?? this[kDocuments].length);\n  }\n\n  [Symbol.asyncIterator](): AsyncIterator<TSchema, void> {\n    return {\n      next: () =>\n        this.next().then(value =>\n          value != null ? { value, done: false } : { value: undefined, done: true }\n        )\n    };\n  }\n\n  stream(options?: CursorStreamOptions): Readable & AsyncIterable<TSchema> {\n    if (options?.transform) {\n      const transform = options.transform;\n      const readable = new ReadableCursorStream(this);\n\n      return readable.pipe(\n        new Transform({\n          objectMode: true,\n          highWaterMark: 1,\n          transform(chunk, _, callback) {\n            try {\n              const transformed = transform(chunk);\n              callback(undefined, transformed);\n            } catch (err) {\n              callback(err);\n            }\n          }\n        })\n      );\n    }\n\n    return new ReadableCursorStream(this);\n  }\n\n  hasNext(): Promise<boolean>;\n  hasNext(callback: Callback<boolean>): void;\n  hasNext(callback?: Callback<boolean>): Promise<boolean> | void {\n    return maybePromise(callback, done => {\n      if (this[kId] === Long.ZERO) {\n        return done(undefined, false);\n      }\n\n      if (this[kDocuments].length) {\n        return done(undefined, true);\n      }\n\n      next<TSchema>(this, true, (err, doc) => {\n        if (err) return done(err);\n\n        if (doc) {\n          this[kDocuments].unshift(doc);\n          done(undefined, true);\n          return;\n        }\n\n        done(undefined, false);\n      });\n    });\n  }\n\n  /** Get the next available document from the cursor, returns null if no more documents are available. */\n  next(): Promise<TSchema | null>;\n  next(callback: Callback<TSchema | null>): void;\n  next(callback?: Callback<TSchema | null>): Promise<TSchema | null> | void;\n  next(callback?: Callback<TSchema | null>): Promise<TSchema | null> | void {\n    return maybePromise(callback, done => {\n      if (this[kId] === Long.ZERO) {\n        return done(new MongoCursorExhaustedError());\n      }\n\n      next(this, true, done);\n    });\n  }\n\n  /**\n   * Try to get the next available document from the cursor or `null` if an empty batch is returned\n   */\n  tryNext(): Promise<TSchema | null>;\n  tryNext(callback: Callback<TSchema | null>): void;\n  tryNext(callback?: Callback<TSchema | null>): Promise<TSchema | null> | void {\n    return maybePromise(callback, done => {\n      if (this[kId] === Long.ZERO) {\n        return done(new MongoCursorExhaustedError());\n      }\n\n      next(this, false, done);\n    });\n  }\n\n  /**\n   * Iterates over all the documents for this cursor using the iterator, callback pattern.\n   *\n   * @param iterator - The iteration callback.\n   * @param callback - The end callback.\n   */\n  forEach(iterator: (doc: TSchema) => boolean | void): Promise<void>;\n  forEach(iterator: (doc: TSchema) => boolean | void, callback: Callback<void>): void;\n  forEach(\n    iterator: (doc: TSchema) => boolean | void,\n    callback?: Callback<void>\n  ): Promise<void> | void {\n    if (typeof iterator !== 'function') {\n      throw new MongoInvalidArgumentError('Argument \"iterator\" must be a function');\n    }\n    return maybePromise(callback, done => {\n      const transform = this[kTransform];\n      const fetchDocs = () => {\n        next<TSchema>(this, true, (err, doc) => {\n          if (err || doc == null) return done(err);\n          let result;\n          // NOTE: no need to transform because `next` will do this automatically\n          try {\n            result = iterator(doc); // TODO(NODE-3283): Improve transform typing\n          } catch (error) {\n            return done(error);\n          }\n\n          if (result === false) return done();\n\n          // these do need to be transformed since they are copying the rest of the batch\n          const internalDocs = this[kDocuments].splice(0, this[kDocuments].length);\n          for (let i = 0; i < internalDocs.length; ++i) {\n            try {\n              result = iterator(\n                (transform ? transform(internalDocs[i]) : internalDocs[i]) as TSchema // TODO(NODE-3283): Improve transform typing\n              );\n            } catch (error) {\n              return done(error);\n            }\n            if (result === false) return done();\n          }\n\n          fetchDocs();\n        });\n      };\n\n      fetchDocs();\n    });\n  }\n\n  close(): Promise<void>;\n  close(callback: Callback): void;\n  /**\n   * @deprecated options argument is deprecated\n   */\n  close(options: CursorCloseOptions): Promise<void>;\n  /**\n   * @deprecated options argument is deprecated\n   */\n  close(options: CursorCloseOptions, callback: Callback): void;\n  close(options?: CursorCloseOptions | Callback, callback?: Callback): Promise<void> | void {\n    if (typeof options === 'function') (callback = options), (options = {});\n    options = options ?? {};\n\n    const needsToEmitClosed = !this[kClosed];\n    this[kClosed] = true;\n\n    return maybePromise(callback, done => cleanupCursor(this, { needsToEmitClosed }, done));\n  }\n\n  /**\n   * Returns an array of documents. The caller is responsible for making sure that there\n   * is enough memory to store the results. Note that the array only contains partial\n   * results when this cursor had been previously accessed. In that case,\n   * cursor.rewind() can be used to reset the cursor.\n   *\n   * @param callback - The result callback.\n   */\n  toArray(): Promise<TSchema[]>;\n  toArray(callback: Callback<TSchema[]>): void;\n  toArray(callback?: Callback<TSchema[]>): Promise<TSchema[]> | void {\n    return maybePromise(callback, done => {\n      const docs: TSchema[] = [];\n      const transform = this[kTransform];\n      const fetchDocs = () => {\n        // NOTE: if we add a `nextBatch` then we should use it here\n        next<TSchema>(this, true, (err, doc) => {\n          if (err) return done(err);\n          if (doc == null) return done(undefined, docs);\n\n          // NOTE: no need to transform because `next` will do this automatically\n          docs.push(doc);\n\n          // these do need to be transformed since they are copying the rest of the batch\n          const internalDocs = (\n            transform\n              ? this[kDocuments].splice(0, this[kDocuments].length).map(transform)\n              : this[kDocuments].splice(0, this[kDocuments].length)\n          ) as TSchema[]; // TODO(NODE-3283): Improve transform typing\n\n          if (internalDocs) {\n            docs.push(...internalDocs);\n          }\n\n          fetchDocs();\n        });\n      };\n\n      fetchDocs();\n    });\n  }\n\n  /**\n   * Add a cursor flag to the cursor\n   *\n   * @param flag - The flag to set, must be one of following ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial' -.\n   * @param value - The flag boolean value.\n   */\n  addCursorFlag(flag: CursorFlag, value: boolean): this {\n    assertUninitialized(this);\n    if (!CURSOR_FLAGS.includes(flag)) {\n      throw new MongoInvalidArgumentError(`Flag ${flag} is not one of ${CURSOR_FLAGS}`);\n    }\n\n    if (typeof value !== 'boolean') {\n      throw new MongoInvalidArgumentError(`Flag ${flag} must be a boolean value`);\n    }\n\n    this[kOptions][flag] = value;\n    return this;\n  }\n\n  /**\n   * Map all documents using the provided function\n   * If there is a transform set on the cursor, that will be called first and the result passed to\n   * this function's transform.\n   *\n   * @remarks\n   * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,\n   * it **does not** return a new instance of a cursor. This means when calling map,\n   * you should always assign the result to a new variable in order to get a correctly typed cursor variable.\n   * Take note of the following example:\n   *\n   * @example\n   * ```typescript\n   * const cursor: FindCursor<Document> = coll.find();\n   * const mappedCursor: FindCursor<number> = cursor.map(doc => Object.keys(doc).length);\n   * const keyCounts: number[] = await mappedCursor.toArray(); // cursor.toArray() still returns Document[]\n   * ```\n   * @param transform - The mapping transformation method.\n   */\n  map<T = any>(transform: (doc: TSchema) => T): AbstractCursor<T> {\n    assertUninitialized(this);\n    const oldTransform = this[kTransform] as (doc: TSchema) => TSchema; // TODO(NODE-3283): Improve transform typing\n    if (oldTransform) {\n      this[kTransform] = doc => {\n        return transform(oldTransform(doc));\n      };\n    } else {\n      this[kTransform] = transform;\n    }\n\n    return this as unknown as AbstractCursor<T>;\n  }\n\n  /**\n   * Set the ReadPreference for the cursor.\n   *\n   * @param readPreference - The new read preference for the cursor.\n   */\n  withReadPreference(readPreference: ReadPreferenceLike): this {\n    assertUninitialized(this);\n    if (readPreference instanceof ReadPreference) {\n      this[kOptions].readPreference = readPreference;\n    } else if (typeof readPreference === 'string') {\n      this[kOptions].readPreference = ReadPreference.fromString(readPreference);\n    } else {\n      throw new MongoInvalidArgumentError(`Invalid read preference: ${readPreference}`);\n    }\n\n    return this;\n  }\n\n  /**\n   * Set the ReadPreference for the cursor.\n   *\n   * @param readPreference - The new read preference for the cursor.\n   */\n  withReadConcern(readConcern: ReadConcernLike): this {\n    assertUninitialized(this);\n    const resolvedReadConcern = ReadConcern.fromOptions({ readConcern });\n    if (resolvedReadConcern) {\n      this[kOptions].readConcern = resolvedReadConcern;\n    }\n\n    return this;\n  }\n\n  /**\n   * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)\n   *\n   * @param value - Number of milliseconds to wait before aborting the query.\n   */\n  maxTimeMS(value: number): this {\n    assertUninitialized(this);\n    if (typeof value !== 'number') {\n      throw new MongoInvalidArgumentError('Argument for maxTimeMS must be a number');\n    }\n\n    this[kOptions].maxTimeMS = value;\n    return this;\n  }\n\n  /**\n   * Set the batch size for the cursor.\n   *\n   * @param value - The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/find/|find command documentation}.\n   */\n  batchSize(value: number): this {\n    assertUninitialized(this);\n    if (this[kOptions].tailable) {\n      throw new MongoTailableCursorError('Tailable cursor does not support batchSize');\n    }\n\n    if (typeof value !== 'number') {\n      throw new MongoInvalidArgumentError('Operation \"batchSize\" requires an integer');\n    }\n\n    this[kOptions].batchSize = value;\n    return this;\n  }\n\n  /**\n   * Rewind this cursor to its uninitialized state. Any options that are present on the cursor will\n   * remain in effect. Iterating this cursor will cause new queries to be sent to the server, even\n   * if the resultant data has already been retrieved by this cursor.\n   */\n  rewind(): void {\n    if (!this[kInitialized]) {\n      return;\n    }\n\n    this[kId] = undefined;\n    this[kDocuments] = [];\n    this[kClosed] = false;\n    this[kKilled] = false;\n    this[kInitialized] = false;\n\n    const session = this[kSession];\n    if (session) {\n      // We only want to end this session if we created it, and it hasn't ended yet\n      if (session.explicit === false) {\n        if (!session.hasEnded) {\n          session.endSession().catch(() => null);\n        }\n        this[kSession] = this.client.startSession({ owner: this, explicit: false });\n      }\n    }\n  }\n\n  /**\n   * Returns a new uninitialized copy of this cursor, with options matching those that have been set on the current instance\n   */\n  abstract clone(): AbstractCursor<TSchema>;\n\n  /** @internal */\n  abstract _initialize(\n    session: ClientSession | undefined,\n    callback: Callback<ExecutionResult>\n  ): void;\n\n  /** @internal */\n  _getMore(batchSize: number, callback: Callback<Document>): void {\n    const cursorId = this[kId];\n    const cursorNs = this[kNamespace];\n    const server = this[kServer];\n\n    if (cursorId == null) {\n      callback(new MongoRuntimeError('Unable to iterate cursor with no id'));\n      return;\n    }\n\n    if (server == null) {\n      callback(new MongoRuntimeError('Unable to iterate cursor without selected server'));\n      return;\n    }\n\n    const getMoreOperation = new GetMoreOperation(cursorNs, cursorId, server, {\n      ...this[kOptions],\n      session: this[kSession],\n      batchSize\n    });\n\n    executeOperation(this[kClient], getMoreOperation, callback);\n  }\n\n  /**\n   * @internal\n   *\n   * This function is exposed for the unified test runner's createChangeStream\n   * operation.  We cannot refactor to use the abstract _initialize method without\n   * a significant refactor.\n   */\n  [kInit](callback: Callback<TSchema | null>): void {\n    this._initialize(this[kSession], (err, state) => {\n      if (state) {\n        const response = state.response;\n        this[kServer] = state.server;\n\n        if (response.cursor) {\n          this[kId] =\n            typeof response.cursor.id === 'number'\n              ? Long.fromNumber(response.cursor.id)\n              : response.cursor.id;\n\n          if (response.cursor.ns) {\n            this[kNamespace] = ns(response.cursor.ns);\n          }\n\n          this[kDocuments] = response.cursor.firstBatch;\n        }\n\n        // When server responses return without a cursor document, we close this cursor\n        // and return the raw server response. This is often the case for explain commands\n        // for example\n        if (this[kId] == null) {\n          this[kId] = Long.ZERO;\n          // TODO(NODE-3286): ExecutionResult needs to accept a generic parameter\n          this[kDocuments] = [state.response as TODO_NODE_3286];\n        }\n      }\n\n      // the cursor is now initialized, even if an error occurred or it is dead\n      this[kInitialized] = true;\n\n      if (err || cursorIsDead(this)) {\n        return cleanupCursor(this, { error: err }, () => callback(err, nextDocument(this)));\n      }\n\n      callback();\n    });\n  }\n}\n\nfunction nextDocument<T>(cursor: AbstractCursor): T | null {\n  if (cursor[kDocuments] == null || !cursor[kDocuments].length) {\n    return null;\n  }\n\n  const doc = cursor[kDocuments].shift();\n  if (doc) {\n    const transform = cursor[kTransform];\n    if (transform) {\n      return transform(doc) as T;\n    }\n\n    return doc;\n  }\n\n  return null;\n}\n\n/**\n * @param cursor - the cursor on which to call `next`\n * @param blocking - a boolean indicating whether or not the cursor should `block` until data\n *     is available.  Generally, this flag is set to `false` because if the getMore returns no documents,\n *     the cursor has been exhausted.  In certain scenarios (ChangeStreams, tailable await cursors and\n *     `tryNext`, for example) blocking is necessary because a getMore returning no documents does\n *     not indicate the end of the cursor.\n * @param callback - callback to return the result to the caller\n * @returns\n */\nexport function next<T>(\n  cursor: AbstractCursor<T>,\n  blocking: boolean,\n  callback: Callback<T | null>\n): void {\n  const cursorId = cursor[kId];\n  if (cursor.closed) {\n    return callback(undefined, null);\n  }\n\n  if (cursor[kDocuments] && cursor[kDocuments].length) {\n    callback(undefined, nextDocument<T>(cursor));\n    return;\n  }\n\n  if (cursorId == null) {\n    // All cursors must operate within a session, one must be made implicitly if not explicitly provided\n    cursor[kInit]((err, value) => {\n      if (err) return callback(err);\n      if (value) {\n        return callback(undefined, value);\n      }\n      return next(cursor, blocking, callback);\n    });\n\n    return;\n  }\n\n  if (cursorIsDead(cursor)) {\n    return cleanupCursor(cursor, undefined, () => callback(undefined, null));\n  }\n\n  // otherwise need to call getMore\n  const batchSize = cursor[kOptions].batchSize || 1000;\n  cursor._getMore(batchSize, (err, response) => {\n    if (response) {\n      const cursorId =\n        typeof response.cursor.id === 'number'\n          ? Long.fromNumber(response.cursor.id)\n          : response.cursor.id;\n\n      cursor[kDocuments] = response.cursor.nextBatch;\n      cursor[kId] = cursorId;\n    }\n\n    if (err || cursorIsDead(cursor)) {\n      return cleanupCursor(cursor, { error: err }, () => callback(err, nextDocument<T>(cursor)));\n    }\n\n    if (cursor[kDocuments].length === 0 && blocking === false) {\n      return callback(undefined, null);\n    }\n\n    next(cursor, blocking, callback);\n  });\n}\n\nfunction cursorIsDead(cursor: AbstractCursor): boolean {\n  const cursorId = cursor[kId];\n  return !!cursorId && cursorId.isZero();\n}\n\nfunction cleanupCursor(\n  cursor: AbstractCursor,\n  options: { error?: AnyError | undefined; needsToEmitClosed?: boolean } | undefined,\n  callback: Callback\n): void {\n  const cursorId = cursor[kId];\n  const cursorNs = cursor[kNamespace];\n  const server = cursor[kServer];\n  const session = cursor[kSession];\n  const error = options?.error;\n  const needsToEmitClosed = options?.needsToEmitClosed ?? cursor[kDocuments].length === 0;\n\n  if (error) {\n    if (cursor.loadBalanced && error instanceof MongoNetworkError) {\n      return completeCleanup();\n    }\n  }\n\n  if (cursorId == null || server == null || cursorId.isZero() || cursorNs == null) {\n    if (needsToEmitClosed) {\n      cursor[kClosed] = true;\n      cursor[kId] = Long.ZERO;\n      cursor.emit(AbstractCursor.CLOSE);\n    }\n\n    if (session) {\n      if (session.owner === cursor) {\n        return session.endSession({ error }, callback);\n      }\n\n      if (!session.inTransaction()) {\n        maybeClearPinnedConnection(session, { error });\n      }\n    }\n\n    return callback();\n  }\n\n  function completeCleanup() {\n    if (session) {\n      if (session.owner === cursor) {\n        return session.endSession({ error }, () => {\n          cursor.emit(AbstractCursor.CLOSE);\n          callback();\n        });\n      }\n\n      if (!session.inTransaction()) {\n        maybeClearPinnedConnection(session, { error });\n      }\n    }\n\n    cursor.emit(AbstractCursor.CLOSE);\n    return callback();\n  }\n\n  cursor[kKilled] = true;\n\n  return executeOperation(\n    cursor[kClient],\n    new KillCursorsOperation(cursorId, cursorNs, server, { session }),\n    completeCleanup\n  );\n}\n\n/** @internal */\nexport function assertUninitialized(cursor: AbstractCursor): void {\n  if (cursor[kInitialized]) {\n    throw new MongoCursorInUseError();\n  }\n}\n\nclass ReadableCursorStream extends Readable {\n  private _cursor: AbstractCursor;\n  private _readInProgress = false;\n\n  constructor(cursor: AbstractCursor) {\n    super({\n      objectMode: true,\n      autoDestroy: false,\n      highWaterMark: 1\n    });\n    this._cursor = cursor;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  override _read(size: number): void {\n    if (!this._readInProgress) {\n      this._readInProgress = true;\n      this._readNext();\n    }\n  }\n\n  override _destroy(error: Error | null, callback: (error?: Error | null) => void): void {\n    this._cursor.close(err => process.nextTick(callback, err || error));\n  }\n\n  private _readNext() {\n    next(this._cursor, true, (err, result) => {\n      if (err) {\n        // NOTE: This is questionable, but we have a test backing the behavior. It seems the\n        //       desired behavior is that a stream ends cleanly when a user explicitly closes\n        //       a client during iteration. Alternatively, we could do the \"right\" thing and\n        //       propagate the error message by removing this special case.\n        if (err.message.match(/server is closed/)) {\n          this._cursor.close().catch(() => null);\n          return this.push(null);\n        }\n\n        // NOTE: This is also perhaps questionable. The rationale here is that these errors tend\n        //       to be \"operation interrupted\", where a cursor has been closed but there is an\n        //       active getMore in-flight. This used to check if the cursor was killed but once\n        //       that changed to happen in cleanup legitimate errors would not destroy the\n        //       stream. There are change streams test specifically test these cases.\n        if (err.message.match(/interrupted/)) {\n          return this.push(null);\n        }\n\n        return this.destroy(err);\n      }\n\n      if (result == null) {\n        this.push(null);\n      } else if (this.destroyed) {\n        this._cursor.close().catch(() => null);\n      } else {\n        if (this.push(result)) {\n          return this._readNext();\n        }\n\n        this._readInProgress = false;\n      }\n    });\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}