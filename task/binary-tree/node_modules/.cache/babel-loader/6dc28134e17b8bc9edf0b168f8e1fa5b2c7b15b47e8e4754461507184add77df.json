{"ast":null,"code":"import React from \"react\";\nclass BinaryTree extends React.Component {\n  constructor(props) {\n    super(props);\n\n    // Define the initial binary tree\n    this.state = {\n      tree: {\n        value: 1,\n        left: null,\n        right: null\n      }\n    };\n  }\n  insert(value) {\n    // Create a new node with the given value\n    const newNode = {\n      value: value,\n      left: null,\n      right: null\n    };\n\n    // If the tree is empty, make the new node the root\n    if (this.state.tree === null) {\n      this.setState({\n        tree: newNode\n      });\n      return;\n    }\n    let currentNode = this.state.tree;\n\n    // Traverse the tree to find the right place to insert the new node\n    while (true) {\n      if (value < currentNode.value) {\n        if (currentNode.left === null) {\n          currentNode.left = newNode;\n          break;\n        }\n        currentNode = currentNode.left;\n      } else {\n        if (currentNode.right === null) {\n          currentNode.right = newNode;\n          break;\n        }\n        currentNode = currentNode.right;\n      }\n    }\n\n    // Update the state with the new tree\n    this.setState({\n      tree: this.state.tree\n    });\n  }\n  componentDidMount() {\n    // Insert some nodes into the tree\n    this.insert(2);\n    this.insert(3);\n    this.insert(1);\n\n    // Traverse the tree\n    this.traverse(this.state.tree);\n  }\n  traverse(node) {\n    if (node !== null) {\n      console.log(node.value);\n      this.traverse(node.left);\n      this.traverse(node.right);\n    }\n  }\n  render() {\n    return null;\n  }\n}\nexport default BinaryTree;","map":{"version":3,"names":["React","BinaryTree","Component","constructor","props","state","tree","value","left","right","insert","newNode","setState","currentNode","componentDidMount","traverse","node","console","log","render"],"sources":["C:/Users/Jatin/Documents/HTML PROJECTS/mern-exercise/task/binary-tree/src/BinaryTree.js"],"sourcesContent":["import React from \"react\";\r\n\r\nclass BinaryTree extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n\r\n    // Define the initial binary tree\r\n    this.state = {\r\n      tree: {\r\n        value: 1,\r\n        left: null,\r\n        right: null,\r\n      },\r\n    };\r\n  }\r\n\r\n  insert(value) {\r\n    // Create a new node with the given value\r\n    const newNode = {\r\n      value: value,\r\n      left: null,\r\n      right: null,\r\n    };\r\n\r\n    // If the tree is empty, make the new node the root\r\n    if (this.state.tree === null) {\r\n      this.setState({ tree: newNode });\r\n      return;\r\n    }\r\n\r\n    let currentNode = this.state.tree;\r\n\r\n    // Traverse the tree to find the right place to insert the new node\r\n    while (true) {\r\n      if (value < currentNode.value) {\r\n        if (currentNode.left === null) {\r\n          currentNode.left = newNode;\r\n          break;\r\n        }\r\n        currentNode = currentNode.left;\r\n      } else {\r\n        if (currentNode.right === null) {\r\n          currentNode.right = newNode;\r\n          break;\r\n        }\r\n        currentNode = currentNode.right;\r\n      }\r\n    }\r\n\r\n    // Update the state with the new tree\r\n    this.setState({ tree: this.state.tree });\r\n  }\r\n\r\n  componentDidMount() {\r\n    // Insert some nodes into the tree\r\n    this.insert(2);\r\n    this.insert(3);\r\n    this.insert(1);\r\n\r\n    // Traverse the tree\r\n    this.traverse(this.state.tree);\r\n  }\r\n\r\n  traverse(node) {\r\n    if (node !== null) {\r\n      console.log(node.value);\r\n      this.traverse(node.left);\r\n      this.traverse(node.right);\r\n    }\r\n  }\r\n\r\n  render() {\r\n    return null;\r\n  }\r\n}\r\n\r\nexport default BinaryTree;\r\n"],"mappings":"AAAA,OAAOA,KAAK,MAAM,OAAO;AAEzB,MAAMC,UAAU,SAASD,KAAK,CAACE,SAAS,CAAC;EACvCC,WAAWA,CAACC,KAAK,EAAE;IACjB,KAAK,CAACA,KAAK,CAAC;;IAEZ;IACA,IAAI,CAACC,KAAK,GAAG;MACXC,IAAI,EAAE;QACJC,KAAK,EAAE,CAAC;QACRC,IAAI,EAAE,IAAI;QACVC,KAAK,EAAE;MACT;IACF,CAAC;EACH;EAEAC,MAAMA,CAACH,KAAK,EAAE;IACZ;IACA,MAAMI,OAAO,GAAG;MACdJ,KAAK,EAAEA,KAAK;MACZC,IAAI,EAAE,IAAI;MACVC,KAAK,EAAE;IACT,CAAC;;IAED;IACA,IAAI,IAAI,CAACJ,KAAK,CAACC,IAAI,KAAK,IAAI,EAAE;MAC5B,IAAI,CAACM,QAAQ,CAAC;QAAEN,IAAI,EAAEK;MAAQ,CAAC,CAAC;MAChC;IACF;IAEA,IAAIE,WAAW,GAAG,IAAI,CAACR,KAAK,CAACC,IAAI;;IAEjC;IACA,OAAO,IAAI,EAAE;MACX,IAAIC,KAAK,GAAGM,WAAW,CAACN,KAAK,EAAE;QAC7B,IAAIM,WAAW,CAACL,IAAI,KAAK,IAAI,EAAE;UAC7BK,WAAW,CAACL,IAAI,GAAGG,OAAO;UAC1B;QACF;QACAE,WAAW,GAAGA,WAAW,CAACL,IAAI;MAChC,CAAC,MAAM;QACL,IAAIK,WAAW,CAACJ,KAAK,KAAK,IAAI,EAAE;UAC9BI,WAAW,CAACJ,KAAK,GAAGE,OAAO;UAC3B;QACF;QACAE,WAAW,GAAGA,WAAW,CAACJ,KAAK;MACjC;IACF;;IAEA;IACA,IAAI,CAACG,QAAQ,CAAC;MAAEN,IAAI,EAAE,IAAI,CAACD,KAAK,CAACC;IAAK,CAAC,CAAC;EAC1C;EAEAQ,iBAAiBA,CAAA,EAAG;IAClB;IACA,IAAI,CAACJ,MAAM,CAAC,CAAC,CAAC;IACd,IAAI,CAACA,MAAM,CAAC,CAAC,CAAC;IACd,IAAI,CAACA,MAAM,CAAC,CAAC,CAAC;;IAEd;IACA,IAAI,CAACK,QAAQ,CAAC,IAAI,CAACV,KAAK,CAACC,IAAI,CAAC;EAChC;EAEAS,QAAQA,CAACC,IAAI,EAAE;IACb,IAAIA,IAAI,KAAK,IAAI,EAAE;MACjBC,OAAO,CAACC,GAAG,CAACF,IAAI,CAACT,KAAK,CAAC;MACvB,IAAI,CAACQ,QAAQ,CAACC,IAAI,CAACR,IAAI,CAAC;MACxB,IAAI,CAACO,QAAQ,CAACC,IAAI,CAACP,KAAK,CAAC;IAC3B;EACF;EAEAU,MAAMA,CAAA,EAAG;IACP,OAAO,IAAI;EACb;AACF;AAEA,eAAelB,UAAU"},"metadata":{},"sourceType":"module","externalDependencies":[]}